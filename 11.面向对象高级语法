建包语句： package 包名 即可建包
导包 相同包的类可以直接访问，但是不同包的类则需要导包才行 通过import 包名.类名  导包可以 自动导
如果一个类中要使用不同包中的相同名称的类 那么只能导入一个类 其它的类要使用全称来访问。
  权限修饰符：用来控制一个成员能够被访问的范围
权限修饰符总共有四种：private->缺省->protected->public  范围由小到大。
private 修饰分成员只能在当前类中访问 
缺省的成员只能在当前类和同一个包中的其他类访问
protect修饰的智能在当前类、同一包的其他类 以及不同包的子类访问
public 修饰的其他的类都能使用。
下面用代码演示一下：
  public class test2 extends Fu {
    public static void main(String[] args) {
        Fu f=new Fu();
        //f.method();//因为缺省的属于包权限，在别的包下不能使用。
        //f.pMethod();//被protected修饰的只能在同一类、包权限 以及子类中能实现
       test2 t=new test2();
        f.publicMethod();
        t.pMethod();
    }

}

自己定义成员（方法、变量、构造器）一般满足条件如下：
  1.成员变量应该私有 
  2.方法应该公开
  3.如果该成员智能本类访问 用private访问
  
final关键字
  可以修饰 类、方法和变量
  用final修饰类 表示该类不能被继承
  用final修饰方法 表示该方法不能被重写
  用final修饰变量 表示该变量智能被赋值一次 
  final修饰基本类型的数据 表示基本类型数据的值不能改变  
  final修饰引用类型的数据 表示该变量地址不能变，当时地址可以改变
  
常量：常量就是用public static final 修饰的成员变量！ 必须要有初始值
常量的好处：可以用于系统的配置信息、方便程序维护、同时提高可读性。
例如：
  public static final String NAME="彦祖夏"
  public static final LOGIN_ADDR="jiangsu"
常量的规定：1.变量应该全部大写 2.多个单词用下划线连接起来。
  常量在编译阶段就把常量全部替换了。
通过案例学习常量 ：
  开发一个超级玛丽游戏，需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向 用了很多不会的  额   先不看代码 主要了解个功能就完事了！
枚举类型：java中的一种特殊类型
作用：用来做信息的标志和分类
定义格式 ： 修饰符 enum 枚举名称{每一行都是罗列枚举类实例的名称}
例如：enum Season{SPRING，SUMMER，AUTUM，WINTER；}
反编译后 源码为：
  public final class Season extends java.lang.Enum<Season>{
    public static final Season SPRING=new Season();
    public static final Season SUMMER=new Season();
    public static final Season AUTUM=new Season();
    public static final Season WINTER=new Season();
    public static Season[] values();
    public static Season valueOf(java.lang.String);
  }
枚举特征 ：枚举都是继承了枚举类型的最终类 不可被继承，构造器都是私有的 不能创建对象。第一行默认 都是罗列枚举对象的名称。
枚举的作用及使用场景：还是分类问题

抽象类：
  什么是抽象类：abstract关键字  可以修饰类 可以方法 如果用abstract修饰类 该类是一个抽象类  用abstract修饰一个方法的话该方法是一个抽象方法
  例如： 修饰符 abstract 类名{}        修饰符 abstract 返回值类型 方法名（）{} 、
  注意事项：
    1.抽象方法不能有方法体 
    2.一个类中定义了抽象方法 这个类也要改成抽象类
  抽象类用于被子类继承，抽象方法约束了子类一定要重写去重新实现。
通过一个案例来巩固抽象类和抽象方法：某加油站推出了两种支付卡，一种预存10000的金卡，后续加油享8折优惠，另一种预存5000的银卡，后续享8.5折
类有的东西 抽象类 都有  抽象类不一定有抽象方法 但是有抽象方法的地方一定是抽象类。
不能用abstract修饰变量、代码块以及内部类
抽象类不能创建对象.....：用反证法来解答  假如抽象类可以创建对象 方法并不能运行。

final 和abstract 是互斥关系：final修饰类  修饰类不能被继承  abstract修饰类就是要类被继承的。所以互斥

抽象类应用：模板方法模式 ：场景 当系统中出现同一个功能多处在开发，该功能中大部分代码一样，只有其中部分可能不同的时候
模板方法模式步骤：
  1.把功能定义成一个所谓的模板方法，放在抽象类中，模板方法只定义通用且确定的代码
  2.把不能决定的代码功能定义为一个抽象方法 让子类去实现。
案例：写作文案例  有两类学生 中学生和小学生 都要写《我的爸爸》这篇论文，每种类型的学生 标题的第一段和最后一段内容必须一样，正文自己发挥。
分析：定义一个抽象学生类，先输出标题和第一段 然后定义一个抽样方法，最后输出最后一段。
public abstract class Student {
    public void write(){
        System.out.println("《我的爸爸》");
        System.out.println("第一段：------------");
        this.writem();
        System.out.println("最后一段------------");
    }
    public abstract void writem();
}
class StudentChild extends Student {

    @Override
    public void writem() {
        System.out.println("我是小学生写的论文中间段！");
    }
}
class StudentMiddle extends Student {

    @Override
    public void writem() {
        System.out.println("我是中学生写的论文中间段！");
    }
}

public class Test {
    public static void main(String[] args) {
        //理解模板方法模式
    StudentChild s1=new StudentChild();
    StudentMiddle s2=new StudentMiddle();
    s1.write();
    s2.write();
    }
}

  



  
  
